<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"koory1st.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-1}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="程序码头">
<meta property="og:url" content="http://koory1st.github.io/page/2/index.html">
<meta property="og:site_name" content="程序码头">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="恶也能多">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://koory1st.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>程序码头</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5a965150a69cef85398f027a23e1c21f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序码头</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">13</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">29</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            

<div class="post-list">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koory1st.github.io/posts/16f1c3b8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="恶也能多">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序码头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/16f1c3b8.html" class="post-title-link" itemprop="url">docker启动kafka</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-23 19:31:01" itemprop="dateCreated datePublished" datetime="2019-11-23T19:31:01+00:00">2019-11-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 13:30:34" itemprop="dateModified" datetime="2022-11-17T13:30:34+00:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="docker启动kafka"><a href="#docker启动kafka" class="headerlink" title="docker启动kafka"></a>docker启动kafka</h1><p>最近在做微服务项目，准备使用kafka作为MQ。<br>自己以前没接触过kafka，所以自己想搭建一个环境，试用一下。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/16f1c3b8.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koory1st.github.io/posts/ed444e84.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="恶也能多">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序码头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/ed444e84.html" class="post-title-link" itemprop="url">docker实践15：使用Docker Compose进行编排</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-15 20:13:41" itemprop="dateCreated datePublished" datetime="2019-07-15T20:13:41+00:00">2019-07-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 13:30:34" itemprop="dateModified" datetime="2022-11-17T13:30:34+00:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="定义第一个容器"><a href="#定义第一个容器" class="headerlink" title="定义第一个容器"></a>定义第一个容器</h1><p>Docker Compose基于docker-compose.yml文件。这个文件定义了集群中要使用的所有容器与配置。用代码的方式定义了如何执行docker run命令。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/ed444e84.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koory1st.github.io/posts/3a7e711a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="恶也能多">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序码头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/3a7e711a.html" class="post-title-link" itemprop="url">docker实践14：负载均衡容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-13 12:12:19" itemprop="dateCreated datePublished" datetime="2019-07-13T12:12:19+00:00">2019-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 13:30:34" itemprop="dateModified" datetime="2022-11-17T13:30:34+00:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NGINX-Proxy"><a href="#NGINX-Proxy" class="headerlink" title="NGINX Proxy"></a>NGINX Proxy</h1><p>这个场景中，我们需要运行一个Nginx服务器，当有新的容器被加载的时候，他会自动发现并更新负载均衡配置。很幸运的是，这些已经被<a target="_blank" rel="noopener" href="http://github.com/jwilder/nginx-proxy">nginx-proxy</a>完成了。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/posts/3a7e711a.html#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koory1st.github.io/posts/c27747c8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="恶也能多">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序码头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/c27747c8.html" class="post-title-link" itemprop="url">docker实践13：docker元数据和标签</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-07 22:54:12" itemprop="dateCreated datePublished" datetime="2019-07-07T22:54:12+00:00">2019-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 13:30:34" itemprop="dateModified" datetime="2022-11-17T13:30:34+00:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h1><p>当容器以docker run方式运行时，可以给容器添加标签。一个容器在任何一个时刻可以有多个标签。</p>
<p>注意这个例子，我们是在CLI里使用标签，而不是使用自动化工具，所以标签并没有使用DNS标记格式。</p>
<h2 id="单标签"><a href="#单标签" class="headerlink" title="单标签"></a>单标签</h2><p>添加单标签需要使用选项<em>l =<value></em> ，下面的例子会给容器加一个user标签并带有一个ID，这样就可以让我们在所有容器中查找指定的user。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -l user=12345 -d redis</span><br></pre></td></tr></table></figure>

<h2 id="外部文件"><a href="#外部文件" class="headerlink" title="外部文件"></a>外部文件</h2><p>可以使用外部文件的方式来添加多个标签。外部文件中要没行有一个标签，这些标签会被添加到容器中。</p>
<p>下面的语句会添加2个标签，一个是user一个是role。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;user=123461&#x27; &gt;&gt; labels &amp;&amp; echo &#x27;role=cache&#x27; &gt;&gt; labels</span><br></pre></td></tr></table></figure>

<p>选项*-label-file=<filename>*会将文件中的每一行设置成容器的标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --label-file=labels -d redis</span><br></pre></td></tr></table></figure>



<h1 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h1><p>镜像的标签和容器的标签的作用相同，不过镜像的标签是写在Dockerfile中的。当容器加载时，镜像的标签会应用到容器实例上。</p>
<h2 id="单标签-1"><a href="#单标签-1" class="headerlink" title="单标签"></a>单标签</h2><p>在Dockerfile中可以使用LABEL 指令设置标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL vendor=Katacoda</span><br></pre></td></tr></table></figure>

<h2 id="多标签"><a href="#多标签" class="headerlink" title="多标签"></a>多标签</h2><p>要想设置多标签，使用下面的格式。  (“\“)用来分割。注意使用DNS格式来关联第三方工具。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL vendor=Katacoda \ com.katacoda.version=0.0.5 \ com.katacoda.build-date=2016-07-01T10:47:29Z \ com.katacoda.course=Docker</span><br></pre></td></tr></table></figure>

<h1 id="查看详细"><a href="#查看详细" class="headerlink" title="查看详细"></a>查看详细</h1><p>标签和元数据仅用来查询或者查看。第一个方法就是用 docker inspect 来查看特定的容器或者镜像。</p>
<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>假设环境中已经有了一个容器叫 rd，和一个镜像叫 katacoda-label-example。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>根据容器的名字或者hash id，可以查看容器的全部的元数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect rd</span><br></pre></td></tr></table></figure>

<p>使用*-f*选项可以指定显示的JSON结果里仅显示Lable的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &quot;&#123;&#123;json .Config.Labels &#125;&#125;&quot; rd</span><br></pre></td></tr></table></figure>

<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>查看镜像的Lable与容器的方式一致，但是略有不同。使用<em>ContainerConfig</em>而不是<em>Config</em>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &quot;&#123;&#123;json .ContainerConfig.Labels &#125;&#125;&quot; katacoda-label-example</span><br></pre></td></tr></table></figure>

<p>这些标签会一直存在，即便在镜像被撤掉标签后，撤掉标签后这个信息会是*<none>*.（These labels will remain even if the image has been untagged. When an image is untagged, it will have the name <em><none></em>.）</p>
<h1 id="根据标签查询"><a href="#根据标签查询" class="headerlink" title="根据标签查询"></a>根据标签查询</h1><p>查看容器或者镜像的容器可以提供很多有用的信息，但是在生产环境中上千个容器中，使用标签来限定返回的个数会很有用。</p>
<h2 id="过滤容器"><a href="#过滤容器" class="headerlink" title="过滤容器"></a>过滤容器</h2><p>使用 docker ps 可以根据lable来过滤指定容器。下面的例子就是过滤lable是<em>user</em>，值是<em>katacoda</em>的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps --filter &quot;label=user=scrapbook&quot;</span><br></pre></td></tr></table></figure>

<h2 id="过滤镜像"><a href="#过滤镜像" class="headerlink" title="过滤镜像"></a>过滤镜像</h2><p>使用同样的方式过滤镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images --filter &quot;label=vendor=Katacoda&quot;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>过滤时使用的key和value都是大小写敏感的。</p>
<h1 id="Daemon标签"><a href="#Daemon标签" class="headerlink" title="Daemon标签"></a>Daemon标签</h1><p>标签也可以应用于Docker的daemon上。当启动一个daemon实例时，可以指定标签，例如在开发服务器或者生产服务器上，指定daemon的角色会是不错的选择。</p>
<p>再之后我们会探讨更多的关于Docker配置和标签使用的更多内容。这里我们简单看一下格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker -d \</span><br><span class="line">  -H unix:///var/run/docker.sock \</span><br><span class="line">  --label com.katacoda.environment=&quot;production&quot; \</span><br><span class="line">  --label com.katacoda.storage=&quot;ssd&quot;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koory1st.github.io/posts/8b647d2c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="恶也能多">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序码头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/8b647d2c.html" class="post-title-link" itemprop="url">docker实践12：使用重启策略保持可用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-07 20:14:22" itemprop="dateCreated datePublished" datetime="2019-07-07T20:14:22+00:00">2019-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 13:30:34" itemprop="dateModified" datetime="2022-11-17T13:30:34+00:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="失败时停止"><a href="#失败时停止" class="headerlink" title="失败时停止"></a>失败时停止</h1><p>Docker将容器的非零退出算作容器崩溃。默认情况，容器崩溃后会一直保持停止状态。</p>
<p>我们这里有个特殊的容器，会发送一条消息，然后退出返回1。这就可以模拟一个容器崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name restart-default scrapbook/docker-restart-example</span><br></pre></td></tr></table></figure>

<p>如果列出所有的容器，包括停止的，就会看到这个停用的容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p>可以看log来定位问题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs restart-default</span><br></pre></td></tr></table></figure>

<h1 id="失败后重启"><a href="#失败后重启" class="headerlink" title="失败后重启"></a>失败后重启</h1><p>根据场景，有可能重启失败的进程就可以解决问题。Docker会自动尝试启动指定次数，直到仍然失败。</p>
<p>命令选项：*–restart=on-failure:#*运行你设置Docker尝试重启的次数。下面的例子，docker会尝试重启3次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name restart-3 --restart=on-failure:3 scrapbook/docker-restart-example</span><br></pre></td></tr></table></figure>

<p>可以查看log，确实重启的3次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs restart-3</span><br></pre></td></tr></table></figure>

<h1 id="一直重启"><a href="#一直重启" class="headerlink" title="一直重启"></a>一直重启</h1><p>最后，可以设置Docker一直重启容器。这个例子中，Docker会一直重启容器，直到容器明确告知停止。</p>
<p>使用<em>always</em>标识，在容器崩溃后会一直尝试重启。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name restart-always --restart=always scrapbook/docker-restart-example</span><br></pre></td></tr></table></figure>

<p>查看log会看到不断尝试重启的记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs restart-always</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koory1st.github.io/posts/4f0a1830.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="恶也能多">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序码头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/4f0a1830.html" class="post-title-link" itemprop="url">docker实践11：管理Log文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-04 21:51:42" itemprop="dateCreated datePublished" datetime="2019-07-04T21:51:42+00:00">2019-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 13:30:34" itemprop="dateModified" datetime="2022-11-17T13:30:34+00:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Docker-Logs"><a href="#Docker-Logs" class="headerlink" title="Docker Logs"></a>Docker Logs</h1><p>一旦启动容器，Docker会记录进程的标准输出和标准错误，并且使用Docker客户端可以访问。</p>
<p>假设后台有一个Redis实例容器在运行，容器名是<em>redis-server</em>。使用Docker客户端，可以使用如下语句来访问标准输出和标准错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs redis-server</span><br></pre></td></tr></table></figure>

<h1 id="SysLog"><a href="#SysLog" class="headerlink" title="SysLog"></a>SysLog</h1><p>Docker默认使用json格式的log文件存储在主机上。这会在硬盘上存储大量的文件，可以把Log文件存储到其他的目标位置。</p>
<p>The Syslog log driver will write all the container logs to the central syslog on the host. “syslog is a widely used standard for message logging. It permits separation of the software that generates messages, the system that stores them, and the software that reports and analyses them.” <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Syslog">Wikipedia</a></p>
<p>This log-driver is designed to be used when syslog is being collected and aggregated by an external system.</p>
<p>使用下面的语句可以把Redis的Log记录进syslog</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis-syslog --log-driver=syslog redis</span><br></pre></td></tr></table></figure>

<p>如果尝试用客户端访问这些Log，会出现错误：<em>FATA[0000] “logs” command is supported only for “json-file” logging driver</em></p>
<p>应该使用syslog 流来访问。</p>
<h1 id="停用记录日志"><a href="#停用记录日志" class="headerlink" title="停用记录日志"></a>停用记录日志</h1><p>当容器日志很冗长的时候可以停用日志。</p>
<p>将log-driver设置成none即可以停用日志。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis-none --log-driver=none redis</span><br></pre></td></tr></table></figure>



<p><em>inspect</em>命令可以查看某个容器的Log配置。下面的命令会输出每个容器Log配置的部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format &#x27;&#123;&#123; .HostConfig.LogConfig &#125;&#125;&#x27; redis-server</span><br><span class="line"></span><br><span class="line">docker inspect --format &#x27;&#123;&#123; .HostConfig.LogConfig &#125;&#125;&#x27; redis-syslog</span><br><span class="line"></span><br><span class="line">docker inspect --format &#x27;&#123;&#123; .HostConfig.LogConfig &#125;&#125;&#x27; redis-none</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koory1st.github.io/posts/69c46de.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="恶也能多">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序码头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/69c46de.html" class="post-title-link" itemprop="url">docker实践10：使用Volumes持久化数据</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-03 22:21:38" itemprop="dateCreated datePublished" datetime="2019-07-03T22:21:38+00:00">2019-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 13:30:34" itemprop="dateModified" datetime="2022-11-17T13:30:34+00:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h1><p>宿主机的*/docker/redis-data*目录映射到容器的 <em>/data</em>目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run  -v /docker/redis-data:/data \</span><br><span class="line">  --name r1 -d redis \</span><br><span class="line">  redis-server --appendonly yes</span><br></pre></td></tr></table></figure>



<p>使用下面的语句可以向Redis实例中pipe数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat data | docker exec -i r1 redis-cli --pipe</span><br></pre></td></tr></table></figure>



<p>在主机上可以查看映射的目录里有Redis的数据文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /docker/redis-data</span><br></pre></td></tr></table></figure>



<p>同样的文件还可以挂在到第二个容器。其中一个应用就是用docker容器起到数据备份的作用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run  -v /docker/redis-data:/backup ubuntu ls /backup</span><br></pre></td></tr></table></figure>

<h1 id="共享卷"><a href="#共享卷" class="headerlink" title="共享卷"></a>共享卷</h1><p>使用*-volumes-from* 可以把源容器的映射的卷映射到目标容器上。</p>
<p>下面的例子，可以把redis容器的卷映射给Ubuntu容器。*/data<em>仅在Redis容器上存在，但是因为</em>-volumes-from*语句，Ubuntu容器也可以访问到数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from r1 -it ubuntu ls /data</span><br></pre></td></tr></table></figure>

<p>这样，就可以访问其他容器的卷，而不必关心这个容器是如何跟主机持久化数据的。</p>
<h1 id="只读卷"><a href="#只读卷" class="headerlink" title="只读卷"></a>只读卷</h1><p>挂在卷会给容器对目录的全部的读取和写入权限。不过可以使用*:ro*命令来限制为只读权限。</p>
<p>如果容器试图修改数据会发生错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /docker/redis-data:/data:ro -it ubuntu rm -rf /data</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koory1st.github.io/posts/e979fd32.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="恶也能多">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序码头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/e979fd32.html" class="post-title-link" itemprop="url">docker实践09:容器间通信-Networks方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-20 14:26:37" itemprop="dateCreated datePublished" datetime="2019-06-20T14:26:37+00:00">2019-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 13:30:34" itemprop="dateModified" datetime="2022-11-17T13:30:34+00:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创建network"><a href="#创建network" class="headerlink" title="创建network"></a>创建network</h1><p>首先要使用cli创建一个network，它可以连接上多个容器，使容器可以彼此相互发现。</p>
<p>这个例子中，我们以创建一个<em>backend-network</em>开始，所有连接到后端的容器都在这个网络上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create backend-network</span><br></pre></td></tr></table></figure>
<p>使用*-net*属性连接到网络</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=redis --net=backend-network redis</span><br></pre></td></tr></table></figure>

<h1 id="Network通信"><a href="#Network通信" class="headerlink" title="Network通信"></a>Network通信</h1><p>与links的通信方式不同，docker的network的行为类似于传统的网络连接-节点可以连接或者卸下连接。</p>
<p>首先你会发现docker不再给容器创建环境变量，不再更新hosts文件。用下面的两个语句可以验证。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=backend-network alpine env</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=backend-network alpine cat /etc/hosts</span><br></pre></td></tr></table></figure>

<p>取而代之的是，容器间通信会通过docker内嵌的DNS服务器。这个dns服务器会被分配到各个容器，IP是127.0.0.11，配置到/etc/resolv.conf文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=backend-network alpine cat /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p>当容器试图使用通用的名字（例如：Redis）去连接其他容器时，DNS服务器会返回对应容器的IP地址。这个例子里，Redis的全名是<em>redis.backend-network</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=backend-network alpine ping -c1 redis</span><br></pre></td></tr></table></figure>

<h1 id="连接两个容器"><a href="#连接两个容器" class="headerlink" title="连接两个容器"></a>连接两个容器</h1><p>docker支持容器同时连接多个网络。</p>
<p>举个例子，让我们再创建一个带有Nodejs的网络，然后与已经建立好的Redis实例通信。</p>
<p>首先用相同的方式建立网络</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create frontend-network</span><br></pre></td></tr></table></figure>

<p>然后使用<em>connect</em>命令，可以把已经存在的实例连接到网络上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect frontend-network redis</span><br></pre></td></tr></table></figure>

<p>当我们启动这个web服务器，并且连接到网络的时候，它就可以与Redis实例通信了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --net=frontend-network katacoda/redis-node-docker-example</span><br></pre></td></tr></table></figure>

<h1 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h1><p>在网络模式下Links方式仍然被支持，并提供了一种方式给容器定义别名。这样会给容器一个额外的Dns入口名字和被发现的方式。When using –link the embedded DNS will guarantee that localised lookup result only on that container where the –link is used.</p>
<p>另一种方式是连接到网络的时候设置别名。</p>
<p>下面的例子就是把Redis实例连接到网络时使用别名db。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create frontend-network2</span><br><span class="line">docker network connect --alias db frontend-network2 redis</span><br></pre></td></tr></table></figure>

<p>当容器试图使用db这个名字请求服务时，会被提供Redis容器的IP。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --net=frontend-network2 alpine ping -c1 db</span><br></pre></td></tr></table></figure>

<h1 id="容器断线"><a href="#容器断线" class="headerlink" title="容器断线"></a>容器断线</h1><p>网络建立好之后，可以使用CLI来查询详细信息。</p>
<p>下面的语句可以列出宿主机上所有的网络。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<p>可以查询网络详细，来看有哪些容器连接在这个网络上，并查看IP。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network inspect frontend-network</span><br></pre></td></tr></table></figure>

<p>下面的语句可以把redis容器从网络<em>frontend-network</em>中断开。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network disconnect frontend-network redis</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koory1st.github.io/posts/993603a4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="恶也能多">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序码头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/993603a4.html" class="post-title-link" itemprop="url">docker实践08:容器间通信-Links方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-20 12:26:37" itemprop="dateCreated datePublished" datetime="2019-06-20T12:26:37+00:00">2019-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 13:30:34" itemprop="dateModified" datetime="2022-11-17T13:30:34+00:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h1><p>容器间连接的大多数场景都是应用服务连接数据仓库。创建连接时的关键是容器名字。给被连接的容器起个友好的名字会让连接变得简单。</p>
<p>运行一个redis，命名成：redis-server。这个redis容器就是我们的数据源容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name redis-server redis</span><br></pre></td></tr></table></figure>

<h1 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h1><p>启动一个容器并连接一个数据源容器需要使用的语句是：*-link &lt;container-name|id&gt;:<alias>*</p>
<p>别名用来配置应用程序容器是如何调用数据源的配置信息的，当更改到其他环境的时候，就不需要再修改配置信息了。</p>
<h2 id="连接如何工作"><a href="#连接如何工作" class="headerlink" title="连接如何工作"></a>连接如何工作</h2><p>这个例子中，我们使用Alpine容器连接到redis-server（别名命名成了redis）。</p>
<p>连接被创建时，docker会做两件事。</p>
<p>一，docker会基于连接，向容器中创建一些环境变量。根据这些环境变量可以根据给定的名字获取到一些信息，比如端口号，ip地址。</p>
<p>通过env命令可以输出所有的环境变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --link redis-server:redis alpine env</span><br></pre></td></tr></table></figure>

<p>二，docker会将容器的Host文件更新3个连接到数据源容器的名字，源名字，别名和hash-id。可以使用cat /etc/hosts来查看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --link redis-server:redis alpine cat /etc/hosts</span><br></pre></td></tr></table></figure>

<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>连接建立之后，可以ping数据源容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --link redis-server:redis alpine ping -c 1 redis</span><br></pre></td></tr></table></figure>

<h1 id="连接到应用"><a href="#连接到应用" class="headerlink" title="连接到应用"></a>连接到应用</h1><p>连接创建之后，应用容器就可以连接到redis了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3000:3000 --link redis-server:redis katacoda/redis-node-docker-example</span><br></pre></td></tr></table></figure>

<h1 id="连接到redis-cli"><a href="#连接到redis-cli" class="headerlink" title="连接到redis-cli"></a>连接到redis-cli</h1><p>使用下面的命令可以启动一个redis-cli容器，并通过别名连接到redis服务容器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --link redis-server:redis redis redis-cli -h redis</span><br></pre></td></tr></table></figure>

<p>使用redis的命令查看redis（比如：KEYS *），quit命令用于退出cli。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://koory1st.github.io/posts/3973859.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="恶也能多">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序码头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/3973859.html" class="post-title-link" itemprop="url">docker实践07:数据容器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-20 11:26:37" itemprop="dateCreated datePublished" datetime="2019-06-20T11:26:37+00:00">2019-06-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-17 13:30:34" itemprop="dateModified" datetime="2022-11-17T13:30:34+00:00">2022-11-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h1><p>数据容器：仅用来存储和管理数据的容器。</p>
<p>被宿主机管理，但是用docker ps命令不会显示。</p>
<p>首先给容器起个通用的名字。然后使用busybox作为基础，因为busybox很小很轻量，在宿主机间访问和移动很方便。</p>
<p>-v 选项用来定义这个容器的哪个位置允许其他容器读取写入数据。</p>
<p>比如创建一个存储配置文件的容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create -v /config --name dataContainer busybox</span><br></pre></td></tr></table></figure>

<h1 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h1><p>可以从当前目录向这个容器内复制文件，使用命令：docker cp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 把config.conf文件复制到dataContainer容器的config路径</span><br><span class="line">docker cp config.conf dataContainer:/config/</span><br></pre></td></tr></table></figure>

<h1 id="挂载卷"><a href="#挂载卷" class="headerlink" title="挂载卷"></a>挂载卷</h1><p>数据容器里已经有我们的config.conf文件了。在运行其他独立的容器时，可以关联这个容器获取文件。</p>
<p>使用*–volumes-from <container>*，可以在其他容器加载的的时候挂载卷。下面的这个例子会启动一个ubuntu容器并关联到数据容器，当列出config文件夹内容时，可以看到数据容器的文件内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from dataContainer ubuntu ls /config</span><br></pre></td></tr></table></figure>

<p>如果容器*/config*目录已经存在的话，volumes-from的路径会覆盖并被使用。</p>
<p>可以同时使用多个文件夹。</p>
<h1 id="导入-导出-容器"><a href="#导入-导出-容器" class="headerlink" title="导入/导出 容器"></a>导入/导出 容器</h1><p>如果想把数据容器移动到其他的机器上，可以把容器导出成 .tar 文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export dataContainer &gt; dataContainer.tar</span><br></pre></td></tr></table></figure>

<p>下面的命令可以把 .tar 文件作为数据容器 导入回docker</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker import dataContainer.tar</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

</div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">恶也能多</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/koory1st" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;koory1st" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">恶也能多</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
